<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=edge"> <!-- Avoid IE compatibility mode, as it breaks layout -->

    <title>Map</title>

    <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
    <link rel="stylesheet" href="https://www.w3schools.com/lib/w3-theme-blue-grey.css">

    <script src="https://code.jquery.com/jquery-3.4.1.min.js"
      integrity="sha384-vk5WoKIaW/vJyUAd9n/wmopsmNhiy+L2Z+SBxGYnUkunIxVxAv/UtMOhba/xskxh"
      crossorigin="anonymous"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.5.0/proj4.js"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/3.0.13/svg.js"></script>
    <script src="projection.js"></script>
    <script src="overpass.js"></script>
    <script src="testdata.json"></script>
    
  </head>

  <body>

  <div id="map" style="width: 1000px; height: 700px; border-style: solid; "></div>
  
  <script>
    var draw;
    SVG.on(document, 'DOMContentLoaded', function() {
      draw = SVG().addTo('#map').size("1000px","700px");
      draw.id("mySVG")
      //Map Background : map-background-color	: #F1EEE8
      overpass.query_streets(function(osm_data) {
          var data = convertOsmData(osm_data);
          drawData(data);
          exportSVG(document.getElementById('mySVG'));
      });
      
    })
    var wgs_bbox = [[52.40021943419403, 10.158920288085938], [52.423726814004645, 10.202608108520508]];
    var size = [$("#map").width(), $("#map").height()];
    
    var projection = new Projection(wgs_bbox, size);
    
    var drawWay=function(way, nodes, style) {
      var waypoints=[];
      way.nodes.forEach(function (nodeid, index) {
        var node=nodes[nodeid];
        var xy=projection.convert([node.lat, node.lon]);
        waypoints=waypoints.concat(xy);
      });
      
      var line=draw.polyline(waypoints);
      line.attr(style);
    }
    
    
    var exportSVG = function(svg) {
      // first create a clone of our svg node so we don't mess the original one
      var clone = svg.cloneNode(true);
      // parse the styles
      parseStyles(clone);

      // create a doctype
      var svgDocType = document.implementation.createDocumentType('svg', "-//W3C//DTD SVG 1.1//EN", "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd");
      // a fresh svg document
      var svgDoc = document.implementation.createDocument('http://www.w3.org/2000/svg', 'svg', svgDocType);
      // replace the documentElement with our clone 
      svgDoc.replaceChild(clone, svgDoc.documentElement);
      // get the data
      var svgData = (new XMLSerializer()).serializeToString(svgDoc);

      // now you've got your svg data, the following will depend on how you want to download it
      // e.g yo could make a Blob of it for FileSaver.js
      /*
      var blob = new Blob([svgData.replace(/></g, '>\n\r<')]);
      saveAs(blob, 'myAwesomeSVG.svg');
      */
      // here I'll just make a simple a with download attribute

      var a = document.createElement('a');
      a.href = 'data:image/svg+xml; charset=utf8, ' + encodeURIComponent(svgData.replace(/></g, '>\n\r<'));
      a.download = 'myAwesomeSVG.svg';
      a.innerHTML = 'download the svg file';
      document.body.appendChild(a);

    };

    var parseStyles = function(svg) {
      var styleSheets = [];
      var i;
      // get the stylesheets of the document (ownerDocument in case svg is in <iframe> or <object>)
      var docStyles = svg.ownerDocument.styleSheets;

      // transform the live StyleSheetList to an array to avoid endless loop
      for (i = 0; i < docStyles.length; i++) {
        styleSheets.push(docStyles[i]);
      }

      if (!styleSheets.length) {
        return;
      }

      var defs = svg.querySelector('defs') || document.createElementNS('http://www.w3.org/2000/svg', 'defs');
      if (!defs.parentNode) {
        svg.insertBefore(defs, svg.firstElementChild);
      }
      svg.matches = svg.matches || svg.webkitMatchesSelector || svg.mozMatchesSelector || svg.msMatchesSelector || svg.oMatchesSelector;


      // iterate through all document's stylesheets
      for (i = 0; i < styleSheets.length; i++) {
        var currentStyle = styleSheets[i]

        var rules;
        try {
          rules = currentStyle.cssRules;
        } catch (e) {
          continue;
        }
        // create a new style element
        var style = document.createElement('style');
        // some stylesheets can't be accessed and will throw a security error
        var l = rules && rules.length;
        // iterate through each cssRules of this stylesheet
        for (var j = 0; j < l; j++) {
          // get the selector of this cssRules
          var selector = rules[j].selectorText;
          // probably an external stylesheet we can't access
          if (!selector) {
            continue;
          }

          // is it our svg node or one of its children ?
          if ((svg.matches && svg.matches(selector)) || svg.querySelector(selector)) {

            var cssText = rules[j].cssText;
            // append it to our <style> node
            style.innerHTML += cssText + '\n';
          }
        }
        // if we got some rules
        if (style.innerHTML) {
          // append the style node to the clone's defs
          defs.appendChild(style);
        }
      }

    };


    
    
    
    
    var rules = [
      {
        "name": "lake",
        "filter": function(tags){
          return (tags.hasOwnProperty("natural") && tags.natural=="water");        
        },
        "cycles": {
          "areas": {
            fill: "#0000ff",
            stroke: "none",
          }
        }
      },
      {
        "name": "river",
        "filter": function(tags){
          return (tags.hasOwnProperty("waterway") && tags.waterway=="river");        
        },
        "cycles": {
          "streets_bg": {
            fill: "none",
            stroke: "#0000ff",
            "stroke-width": 5,
          }
        }
      },
      {
        "name": "cycleway",
        "filter": function(tags){
          return (tags.hasOwnProperty("highway") && tags.highway=="cycleway");        
        },
        "cycles": {
          "streets_bg": {
            fill: "none",
            stroke: "#ffffff",
            "stroke-width": 3,
            "stroke-linecap": "round",
            opacity: 0.3
          },
          "streets_fg": {
            fill: "none",
            stroke: "#F68474",
            "stroke-width": 2,
            "stroke-linecap": "round",
            "stroke-dasharray":"5,5"
          }
        }
      },
      {
        "name": "livingstreet",
        "filter": function(tags){
          return (tags.hasOwnProperty("highway") && tags.highway=="living_street");        
        },
        "cycles": {
          "streets_bg": {
            fill: "none",
            stroke: "#aaaaaa",
            "stroke-linecap": "round",
            "stroke-width": 5
          },
          "streets_fg": {
            fill: "none",
            stroke: "#dddddd",
            "stroke-linecap": "round",
            "stroke-width": 3
          }
        }
      },
      {
        "name": "residential",
        "filter": function(tags){
          return (tags.hasOwnProperty("highway") && tags.highway=="residential");        
        },
        "cycles": {
          "streets_bg": {
            fill: "none",
            stroke: "#aaaaaa",
            "stroke-linecap": "round",
            "stroke-width": 5
          },
          "streets_fg": {
            fill: "none",
            stroke: "#ffffff",
            "stroke-linecap": "round",
            "stroke-width": 3
          }
        }
      },
      {
        "name": "tertiary",
        "filter": function(tags){
          return (tags.hasOwnProperty("highway") && tags.highway=="tertiary");        
        },
        "cycles": {
          "streets_bg": {
            fill: "none",
            stroke: "#cbcb8e",
            "stroke-linecap": "round",
            "stroke-width": 7
          },
          "streets_fg": {
            fill: "none",
            stroke: "#FEFEB2",
            "stroke-linecap": "round",
            "stroke-width": 5
          }
        }
      },

    ]
    
    var cycles = ["areas", "streets_bg", "streets_fg"];
    
    var drawData=function(data) {
      cycles.forEach(function(cycle, index) {
        rules.forEach(function(rule, index) {
          if (rule.cycles.hasOwnProperty(cycle)) {

            for (var key in data.ways) {
              if (data.ways.hasOwnProperty(key)) {
                var way=data.ways[key];
                if (way.hasOwnProperty("tags")) {
                  if (rule.filter(way.tags)) {
                    drawWay(way, data.nodes, rule.cycles[cycle]);
                  }
                }
              }
            }
          }
        });
      });
    }

    var convertOsmData=function(osm_data) {
      var nodes={};
      var ways={};
      
      //loop over each element
      osm_data.elements.forEach(function(el, index) {
        if (el.type=="way") {
          ways[el.id]=el;
        }
        else if (el.type=="node") {
          nodes[el.id]=el;
        }
        else {
          console.log("Type " + el.type + " unsupported.");
        }
      });
      
      return { "ways": ways, "nodes": nodes };
      
    }

    
  


  </script>


  
  
  </body>
</html>
